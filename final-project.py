# -*- coding: utf-8 -*-
"""Untitled14.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yuQ5k5A0bMZmmu3WBaW8HZwJF4IfS5Pl
"""

# from zipfile import ZipFile

# with ZipFile("./sample_data/data_16.zip", 'r') as zObject:

#     # Extracting all the members of the zip
#     # into a specific location.
#     zObject.extractall(
#         path="./sample_data/data_16")

from pyspark.ml.classification import RandomForestClassifier
from pyspark.ml.regression import RandomForestRegressor
from pyspark.ml.feature import PCA
from pyspark.ml.feature import VectorAssembler
from pyspark.ml import Pipeline
from pyspark.ml.linalg import Vectors
from pyspark.sql import SparkSession
from pyspark.sql.functions import explode, split, col
from pyspark.ml.evaluation import RegressionEvaluator
from pyspark.sql.types import DoubleType
from pyspark.sql.functions import explode
from pyspark.sql.functions import split
from pyspark.sql.functions import col
from pyspark.sql.window import Window
from pyspark.sql import functions as F
from pyspark.sql import Row
from pyspark.sql.types import StructType, StructField, StringType, IntegerType, FloatType

spark = SparkSession.builder.appName("FIFA_team_win").getOrCreate()

# we are considering fifa version 16 game - data as it is built on season 15 player's performance data
data_path = './sample_data/data_16/'

data = spark.read.csv(data_path, header=True, inferSchema=True)

selected_columns = ["fifa_version", "player_positions", "overall", "potential", "age", "height_cm", "weight_kg",
                    "weak_foot", "skill_moves", "club_name","long_name",
                    "attacking_crossing", "attacking_finishing", "attacking_heading_accuracy",
                    "attacking_short_passing", "attacking_volleys", "skill_dribbling", "skill_curve",
                    "skill_fk_accuracy", "skill_long_passing", "skill_ball_control", "movement_acceleration",
                    "movement_sprint_speed", "movement_agility", "movement_reactions", "movement_balance",
                    "power_shot_power", "power_jumping", "power_stamina", "power_strength", "power_long_shots",
                    "mentality_aggression", "mentality_interceptions", "mentality_positioning", "mentality_vision",
                    "mentality_penalties", "defending_marking_awareness", "defending_standing_tackle",
                    "defending_sliding_tackle"]
fifa_16_data = data.select(selected_columns)

# Removing Goalkeeper data as it deviates alot from outfield players which might impact modell training
fifa_16_data = fifa_16_data.filter(~fifa_16_data['player_positions'].contains("GK"))

# All possible player positions
attack_positions = ['ST', 'RW', 'LW', 'CF']
midfield_positions = ['CAM', 'CM', 'CDM', 'RM', 'LM']
defense_positions = ['CB', 'LB', 'RB', 'RWB', 'LWB']

# Dividing the data into three RDDs based on player positions
attack_data = fifa_16_data.filter(fifa_16_data['player_positions'].isin(attack_positions))
midfield_data = fifa_16_data.filter(fifa_16_data['player_positions'].isin(midfield_positions))
defense_data = fifa_16_data.filter(fifa_16_data['player_positions'].isin(defense_positions))

importances_list = []
# Defining a function to feature select/eliminate each RDD based on RandomForestClassifier column importance
def process_data(rdd):
    global counter
    global importances_list
    rdd = rdd.drop('player_positions')
    least_important_features_lists= []
    feature_columns = ["overall", "potential", "age", "height_cm", "weight_kg",
                       "weak_foot", "skill_moves",
                       "attacking_crossing", "attacking_finishing", "attacking_heading_accuracy",
                       "attacking_short_passing", "attacking_volleys", "skill_dribbling", "skill_curve",
                       "skill_fk_accuracy", "skill_long_passing", "skill_ball_control", "movement_acceleration",
                       "movement_sprint_speed", "movement_agility", "movement_reactions", "movement_balance",
                       "power_shot_power", "power_jumping", "power_stamina", "power_strength", "power_long_shots",
                       "mentality_aggression", "mentality_interceptions", "mentality_positioning", "mentality_vision",
                       "mentality_penalties", "defending_marking_awareness", "defending_standing_tackle",
                       "defending_sliding_tackle"]

    assembler = VectorAssembler(inputCols=feature_columns, outputCol='features')
    rdd = assembler.transform(rdd)

    rf_classifier = RandomForestClassifier(featuresCol='features', labelCol='overall', numTrees=100)
    model = rf_classifier.fit(rdd)
    importances = model.featureImportances.toArray()
    print(importances)
    importances_list.append(importances)
    least_important_features = [i for i, importance in enumerate(importances) if importance < 0.01]

    # Removing least important features
    for feature_index in reversed(least_important_features):
        least_important_features_lists.append(feature_index)
        rdd = rdd.drop(feature_columns[feature_index])

    return rdd, least_important_features_lists

processed_attack_data,attack_least_important_features_lists  = process_data(attack_data)
processed_midfield_data,midfield_least_important_features_lists = process_data(midfield_data)
processed_defense_data,defense_least_important_features_lists = process_data(defense_data)

# Appling PCA for futher feature Engineering
num_principal_components = 8
pca = PCA(k=num_principal_components, inputCol="features", outputCol="pca_features")

pca_attack = pca.fit(processed_attack_data)
pca_midfield = pca.fit(processed_midfield_data)
pca_defense = pca.fit(processed_defense_data)

processed_attack_data = pca_attack.transform(processed_attack_data)
processed_midfield_data = pca_midfield.transform(processed_midfield_data)
processed_defense_data = pca_defense.transform(processed_defense_data)

# Split data into train and test
train_attack_data, test_attack_data = processed_attack_data.randomSplit([0.8, 0.2], seed=42)
train_midfield_data, test_midfield_data = processed_midfield_data.randomSplit([0.8, 0.2], seed=42)
train_defense_data, test_defense_data = processed_defense_data.randomSplit([0.8, 0.2], seed=42)

# Define RandomForestRegressor models
rf_regressor_attack = RandomForestRegressor(numTrees=500, featuresCol='pca_features', labelCol='overall', seed=42)
rf_regressor_midfield = RandomForestRegressor(numTrees=500, featuresCol='pca_features', labelCol='overall', seed=42)
rf_regressor_defense = RandomForestRegressor(numTrees=500, featuresCol='pca_features', labelCol='overall', seed=42)


pipeline_attack = Pipeline(stages=[rf_regressor_attack])
pipeline_midfield = Pipeline(stages=[rf_regressor_midfield])
pipeline_defense = Pipeline(stages=[rf_regressor_defense])

# Train the RandomForestRegressor models and Make predictions on the test sets
model_attack = pipeline_attack.fit(train_attack_data)
model_midfield = pipeline_midfield.fit(train_midfield_data)
model_defense = pipeline_defense.fit(train_defense_data)

predictions_attack = model_attack.transform(test_attack_data)
predictions_midfield = model_midfield.transform(test_midfield_data)
predictions_defense = model_defense.transform(test_defense_data)

# Evaluate the models based on on RMSE metric
evaluator = RegressionEvaluator(labelCol='overall', predictionCol='prediction', metricName='rmse')
rmse_attack = evaluator.evaluate(predictions_attack)
rmse_midfield = evaluator.evaluate(predictions_midfield)
rmse_defense = evaluator.evaluate(predictions_defense)

print(f"RMSE for Attack: {rmse_attack}")
print(f"RMSE for Midfield: {rmse_midfield}")
print(f"RMSE for Defense: {rmse_defense}")

# Explode the 'player_positions' column as it contains multiple values
fifa_data_exploded = fifa_16_data.withColumn('position', explode(split(fifa_16_data['player_positions'], ', ')))

# Get the best squad for given club based on overall rating
def get_best_squad(position, club='*', measurement='overall'):
    if club != '*':
        fifa_data_filtered = fifa_data_exploded.filter(fifa_data_exploded['club_name'] == club)
    else:
        fifa_data_filtered = fifa_data_exploded

    distinct_df = fifa_data_filtered.dropDuplicates(['long_name'])
    filtered_df = distinct_df.filter(distinct_df['position'].isin(position))
    window_spec = Window.partitionBy('position').orderBy(F.col(measurement).desc())

    # Rank players within each position group
    ranked_df = filtered_df.withColumn("rank", F.rank().over(window_spec)).filter(F.col("rank") == 1)

    return ranked_df

# We can set any formation we want here so that all future analysis will be done on this formation
squad_formation = ['LW', 'RW', 'ST', 'CAM', 'CM', 'CM', 'CDM', 'RB', 'CB', 'LB']

# Feature selection to the given squad based on above trained RandomForestClassifier importance
def process_best_squd_data(rdd, least_important_features_list):
    rdd = rdd.drop('player_positions')
    feature_columns = ["overall", "potential", "age", "height_cm", "weight_kg",
                       "weak_foot", "skill_moves",
                       "attacking_crossing", "attacking_finishing", "attacking_heading_accuracy",
                       "attacking_short_passing", "attacking_volleys", "skill_dribbling", "skill_curve",
                       "skill_fk_accuracy", "skill_long_passing", "skill_ball_control", "movement_acceleration",
                       "movement_sprint_speed", "movement_agility", "movement_reactions", "movement_balance",
                       "power_shot_power", "power_jumping", "power_stamina", "power_strength", "power_long_shots",
                       "mentality_aggression", "mentality_interceptions", "mentality_positioning", "mentality_vision",
                       "mentality_penalties", "defending_marking_awareness", "defending_standing_tackle",
                       "defending_sliding_tackle"]

    assembler = VectorAssembler(inputCols=feature_columns, outputCol='features')
    rdd = assembler.transform(rdd)
    # Removing least important features
    for feature_index in least_important_features_list:
        rdd = rdd.drop(feature_columns[feature_index])

    return rdd

# All the clubs of player's in 2016 version of FIFA data
clubs = fifa_16_data.select("club_name").distinct().rdd.flatMap(lambda x: x).collect()

# All the clubs from UEFA champion's league data
champs_df = spark.read.csv('champs.csv', header=True, inferSchema=True)

# Filter data for the 2015 season as we are working on 2015 data
matches_2015 = champs_df.filter(champs_df['Season'] == 2015)

selected_columns = ["Date", "Season", "round", "home", "visitor", "FT", "HT", "aet", "pens",
                     "hgoal", "vgoal", "FTagg_home", "FTagg_visitor", "aethgoal", "aetvgoal",
                     "tothgoal", "totvgoal", "totagg_home", "totagg_visitor", "tiewinner",
                     "hcountry", "vcountry"]

matches_2015_selected = matches_2015.select(selected_columns)

# All the clubs from UEFA champion's league data of 2015
unique_home_values = matches_2015_selected.select("home").distinct()
unique_home_list = [row.home for row in unique_home_values.collect()]

common_values = set(clubs).intersection(unique_home_list)

# Now we are buildaing a dictionary of all the UEFA champion's league participating clubs' name and their best squad average of predicted future overall rating
club_ratings_dict = {}

for club in common_values:
    best_squad_Overall = get_best_squad(squad_formation, club, 'overall')

    attack_data = best_squad_Overall.filter(best_squad_Overall['position'].isin(attack_positions))
    midfield_data = best_squad_Overall.filter(best_squad_Overall['position'].isin(midfield_positions))
    defense_data = best_squad_Overall.filter(best_squad_Overall['position'].isin(defense_positions))


    processed_attack_data = process_best_squd_data(attack_data, attack_least_important_features_lists)
    processed_midfield_data = process_best_squd_data(midfield_data, midfield_least_important_features_lists)
    processed_defense_data = process_best_squd_data(defense_data, defense_least_important_features_lists)


    processed_attack_data = pca_attack.transform(processed_attack_data)
    processed_midfield_data = pca_midfield.transform(processed_midfield_data)
    processed_defense_data = pca_defense.transform(processed_defense_data)


    predictions_attack = model_attack.transform(processed_attack_data)
    predictions_midfield = model_midfield.transform(processed_midfield_data)
    predictions_defense = model_defense.transform(processed_defense_data)

    average_rating =[]

    if not predictions_attack.isEmpty():
        average_rating.append(predictions_attack.select(F.avg('overall')).collect()[0][0])
    if not predictions_midfield.isEmpty():
        average_rating.append(predictions_midfield.select(F.avg('overall')).collect()[0][0])
    if not predictions_defense.isEmpty():
        average_rating.append(predictions_defense.select(F.avg('overall')).collect()[0][0])
    # Calculate the overall average rating
    if average_rating:
        overall_average_rating = sum(average_rating) / len(average_rating)
        club_ratings_dict[club] = overall_average_rating

print(club_ratings_dict)

#Appending Club Ratings to  UEFA champion's league matches data
club_ratings_df = spark.createDataFrame(list(club_ratings_dict.items()), ['club', 'rating'])

matches_2015_selected = matches_2015_selected.join(club_ratings_df.withColumnRenamed('club', 'home'),
                                                   on='home', how='left_outer')
matches_2015_selected = matches_2015_selected.withColumnRenamed('rating', 'home_rating')
matches_2015_selected = matches_2015_selected.join(club_ratings_df.withColumnRenamed('club', 'visitor'),
                                                   on='visitor', how='left_outer')
matches_2015_selected = matches_2015_selected.withColumnRenamed('rating', 'away_rating')

matches_2015_selected = matches_2015_selected.na.fill(0)
matches_2015_selected = matches_2015_selected.filter((col("home_rating") != 0) & (col("away_rating") != 0))
matches_2015_selected = matches_2015_selected.withColumn("result",
                                                         when(col("hgoal") > col("vgoal"), 1)
                                                         .otherwise(0))

# Now with combined past match winning data and furture possible rating we can create a model to predict future match outcome
selected_columns = ["home_rating", "away_rating", "result"]
preprocessed_2015_data = matches_2015_selected.select(selected_columns)

feature_columns = ["home_rating", "away_rating"]
assembler = VectorAssembler(inputCols=feature_columns, outputCol='new_features')
preprocessed_2015_data = assembler.transform(preprocessed_2015_data)
preprocessed_2015_data

train_data, test_data = preprocessed_2015_data.randomSplit([0.8, 0.2], seed=42)

# Definimg RandomForestClassifier model for match outcome/result prediction
rf_classifier = RandomForestClassifier(featuresCol='new_features', labelCol='result', numTrees=5000)

pipeline = Pipeline(stages=[rf_classifier])
model = pipeline.fit(train_data)
predictions = model.transform(test_data)
predictions.select("home_rating", "away_rating", "result", "prediction").show()

# Evaluate the RandomForestClassifier model
evaluator = RegressionEvaluator(labelCol='result', predictionCol='prediction', metricName='rmse')
rmse = evaluator.evaluate(predictions)
print(f"RMSE for prediction: {rmse}")



# Select a home team to predict outcome
home_team = "Arsenal"
best_squad_home_Overall = get_best_squad(squad_formation, home_team, 'overall')

# Select a away team to predict outcome
away_team = "Chelsea"
best_squad_away_Overall = get_best_squad(squad_formation, away_team, 'overall')

# Preprocessing the best possible squad and making feature engineering for two teams squads
attack_data_home = best_squad_home_Overall.filter(best_squad_home_Overall['position'].isin(attack_positions))
midfield_data_home = best_squad_home_Overall.filter(best_squad_home_Overall['position'].isin(midfield_positions))
defense_data_home = best_squad_home_Overall.filter(best_squad_home_Overall['position'].isin(defense_positions))

attack_data_away = best_squad_away_Overall.filter(best_squad_away_Overall['position'].isin(attack_positions))
midfield_data_away = best_squad_away_Overall.filter(best_squad_away_Overall['position'].isin(midfield_positions))
defense_data_away = best_squad_away_Overall.filter(best_squad_away_Overall['position'].isin(defense_positions))

attack_least_important_features_lists = model_attack.featureImportances.toArray()
midfield_least_important_features_lists = model_midfield.featureImportances.toArray()
defense_least_important_features_lists = model_defense.featureImportances.toArray()

processed_attack_data_home = process_best_squd_data(attack_data_home, attack_least_important_features_lists)
processed_midfield_data_home = process_best_squd_data(midfield_data_home, midfield_least_important_features_lists)
processed_defense_data_home = process_best_squd_data(defense_data_home, defense_least_important_features_lists)

processed_attack_data_away = process_best_squd_data(attack_data_away, attack_least_important_features_lists)
processed_midfield_data_away = process_best_squd_data(midfield_data_away, midfield_least_important_features_lists)
processed_defense_data_away = process_best_squd_data(defense_data_away, defense_least_important_features_lists)

processed_attack_data_home = pca_attack.transform(processed_attack_data_home)
processed_midfield_data_home = pca_midfield.transform(processed_midfield_data_home)
processed_defense_data_home = pca_defense.transform(processed_defense_data_home)

processed_attack_data_away = pca_attack.transform(processed_attack_data_away)
processed_midfield_data_away = pca_midfield.transform(processed_midfield_data_away)
processed_defense_data_away = pca_defense.transform(processed_defense_data_away)

predictions_attack_home = model_attack_r.transform(processed_attack_data_home)
predictions_midfield_home = model_midfield_r.transform(processed_midfield_data_home)
predictions_defense_home = model_defense_r.transform(processed_defense_data_home)

predictions_attack_away = model_attack_r.transform(processed_attack_data_away)
predictions_midfield_away = model_midfield_r.transform(processed_midfield_data_away)
predictions_defense_away = model_defense_r.transform(processed_defense_data_away)


# Calculating average predicted future overall rating for current match for home and away teams
average_rating =[]

if not predictions_attack_home.isEmpty():
    average_rating.append(predictions_attack_home.select(F.avg('overall')).collect()[0][0])

if not predictions_midfield_home.isEmpty():
    average_rating.append(predictions_midfield_home.select(F.avg('overall')).collect()[0][0])

if not predictions_defense_home.isEmpty():
    average_rating.append(predictions_defense_home.select(F.avg('overall')).collect()[0][0])

if average_rating:
    overall_average_rating_home = sum(average_rating) / len(average_rating)
else:
    overall_average_rating_home = 0

average_rating = []

if not predictions_attack_away.isEmpty():
    average_rating.append(predictions_attack_away.select(F.avg('overall')).collect()[0][0])

if not predictions_midfield_away.isEmpty():
    average_rating.append(predictions_midfield_away.select(F.avg('overall')).collect()[0][0])

if not predictions_defense_away.isEmpty():
    average_rating.append(predictions_defense_away.select(F.avg('overall')).collect()[0][0])

if average_rating:
    overall_average_rating_away = sum(average_rating) / len(average_rating)
else:
    overall_average_rating_away = 0

# Creating a data frame based on this home and away team's predicted future overall rating
schema = StructType([
    StructField("home_rating", FloatType(), True),
    StructField("away_rating", FloatType(), True)
])

row = Row(home_rating=overall_average_rating_home, away_rating=overall_average_rating_away)


match_ratings_df = spark.createDataFrame([row], schema)
assembled_match_data = assembler.transform(match_ratings_df)
predictions = model.transform(assembled_match_data)

predictions.show()
best_squad_home_Overall.show()
best_squad_away_Overall.show()

#predicting outcome of match between these two teams
result = predictions.select('prediction').collect()[0][0]
probability = predictions.select('probability').collect()[0][0]

if(result == 1):
    print(str(home_team) + " is more likely to win with probability of " + str(probability[1]))
else:
    print(str(away_team) + " is more likely to win with probability of " + str(probability[0]))

if(average_rating_home[0] > average_rating_away[0]):
    print(str(home_team)+" is most attacking team")
elif(average_rating_home[0] < average_rating_away[0]):
    print(str(away_team)+" is most attacking team")
else:
    print("Both are equal in attack")

if(average_rating_home[1] > average_rating_away[1]):
    print(str(home_team)+" is most midfield team")
elif(average_rating_home[1] < average_rating_away[1]):
    print(str(away_team)+" is most midfield team")
else:
    print("Both are equal in midfield")


if(average_rating_home[2] > average_rating_away[2]):
    print(str(home_team)+" is most defensive team")
elif(average_rating_home[2] < average_rating_away[2]):
    print(str(away_team)+" is most defensive team")
else:
    print("Both are equal in defense")

importances_attack = model_attack.featureImportances.toArray()
importances_mid = model_midfield.featureImportances.toArray()
importances_def = model_defense.featureImportances.toArray()
feature_columns = ["overall", "potential", "age", "height_cm", "weight_kg",
                       "weak_foot", "skill_moves",
                       "attacking_crossing", "attacking_finishing", "attacking_heading_accuracy",
                       "attacking_short_passing", "attacking_volleys", "skill_dribbling", "skill_curve",
                       "skill_fk_accuracy", "skill_long_passing", "skill_ball_control", "movement_acceleration",
                       "movement_sprint_speed", "movement_agility", "movement_reactions", "movement_balance",
                       "power_shot_power", "power_jumping", "power_stamina", "power_strength", "power_long_shots",
                       "mentality_aggression", "mentality_interceptions", "mentality_positioning", "mentality_vision",
                       "mentality_penalties", "defending_marking_awareness", "defending_standing_tackle",
                       "defending_sliding_tackle"]

for i in range(len(importances_attack)):
    print(f"{feature_columns[i]}: {importances[i]}")
for i in range(len(importances_mid)):
    print(f"{feature_columns[i]}: {importances[i]}")
for i in range(len(importances_def)):
    print(f"{feature_columns[i]}: {importances[i]}")

import matplotlib.pyplot as plt

# Creating a dictionary mapping feature names to their importances
feature_importances = dict(zip(feature_columns, importances_attack))

sorted_features = sorted(feature_importances.items(), key=lambda x: x[1], reverse=True)

sorted_feature_names, sorted_importances = zip(*sorted_features)

plt.figure(figsize=(10, 6))
plt.plot(sorted_feature_names, sorted_importances, marker='o')
plt.xticks(rotation=90)
plt.xlabel('Features')
plt.ylabel('Importance')
plt.title('Feature Importances for attack')
plt.grid(True)
plt.show()

feature_importances = dict(zip(feature_columns, importances_mid))

sorted_features = sorted(feature_importances.items(), key=lambda x: x[1], reverse=True)

sorted_feature_names, sorted_importances = zip(*sorted_features)

plt.figure(figsize=(10, 6))
plt.plot(sorted_feature_names, sorted_importances, marker='o')
plt.xticks(rotation=90)
plt.xlabel('Features')
plt.ylabel('Importance')
plt.title('Feature Importances for midfield')
plt.grid(True)
plt.show()

feature_importances = dict(zip(feature_columns, importances_def))

sorted_features = sorted(feature_importances.items(), key=lambda x: x[1], reverse=True)

sorted_feature_names, sorted_importances = zip(*sorted_features)

plt.figure(figsize=(10, 6))
plt.plot(sorted_feature_names, sorted_importances, marker='o')
plt.xticks(rotation=90)
plt.xlabel('Features')
plt.ylabel('Importance')
plt.title('Feature Importances for defense')
plt.grid(True)
plt.show()

